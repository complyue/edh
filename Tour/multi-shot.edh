
{
  method asyncRisk( n ) {
    defer {
      ; -1<| 'async defer cleanup #' ++ n
    }

    throw '!AsyncFailure#' ++ n

    ; -1<| 'not a chance to see this'
  }

  {
    for i from range( 3 ) do go asyncRisk( i )

    throw '!SyncFailure'
  } @=> { # this finally block will only run by the thread
    # installed it, i.e. the forker thread
    { exc } -> { # forker's finally block only knows about sync
      # exceptions
      ; -1<| 'forker cleanup with a failure: ' ++ exc
    }
    ; -1<| 'forker cleanup without failure'
  } $=> { exc } -> { # this exception handler will be triggered
    # to run in multiple forked threads (forkees), as well as in
    # the forker thread. but its recover continuation will only
    # run by the thread installed it, i.e. the forker thread.
    ; -1<| 'handling ' ++ exc
  }

  # too obviously, but it could really go wrong with,
  # a continuation based implementation
  ; -1<| 'this should run only once by forker thread'

  for _ from console.everyMillis( 10 ) do break

  ; -1<| 'all done.'
}


# Note:
# we use negative log level to trigger debug trace, so thread
# id is shown as well;
# and the minus sign (-) will parse as infix subtraction
# operator if following some expression, so we prefix it with
# a semicolon (;) to disambiguate;
# then `;-1<| 'xxx'` reads `trace "xxx"` with extra info
