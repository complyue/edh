
import * './str'

export {

  if console.logLevel <= console.debug then {

    # world-wide indicator whether the world is under debugging
    debug=this # alias to this module when debugging

    # the advantage of being an interpreter procedure here, is no eval of rest
    # exprs as long as the assertion stands
    interpreter assert( callerScope,
      assertion, msg=None, ***details
    ) case callerScope.eval( assertion ) of {
      true -> { pass } # as it should be

      # other values are unexpected
      nil -> { result = '<nil>'; fallthrough }
      { result } -> { fallthrough }

      detailsResult = if null $ details
      then () # empty apk, don't bother eval it
      # note in below we localize artifacts (avoid polluting the outer scope),
      # with a scoped block {@ ... @}
      else {@ case d = callerScope.eval(*** details ) | type of {
          nil -> () # a very corner case, convert to an empty apk
          ArgsPackType -> d
          _ -> ( d, ) # single value, convert to an apk
      } @}

      error(
        msg &> callerScope.eval( msg ) |> 'assertion failed',
        # following goes as the thrown exception's @.details@
        result=result, ***detailsResult
      )
    }

  } else {

    debug=false # not debugging

    # assert being nop when not debugging
    method assert(*** _ ) pass

  }

  # used to create unique command objects
  class Command { __repr__ = 'Command()' }

  # the default basic implementation for the `dir` command
  interpreter printDir( callerScope, ofScope=None, ) {
    ofScope = ofScope &> callerScope.eval( ofScope ) |> callerScope
    console.print( ofScope.lexiLoc, **ofScope.attrs() )
  }

  # basic implementation of a string form for `dir` command to
  # output to a remote console
  interpreter sprintDir( callerScope, ofScope=None, ) {
    ofScope = ofScope &> callerScope.eval( ofScope ) |> callerScope

    return join(
      ofScope.lexiLoc,
      *() =< for ( k, v ) from ofScope.attrs() do
      '  ' ++ k ++ '=' ++ v,
      sep= '\n',
    )
  }

  # common shell commands
  quit := Command()
  dir := Command()

  interpreter shellHere( callerScope, prompt=None ) {
    prompt = prompt &> callerScope.eval( prompt ) |> repr( callerScope )

    console.print(
      ' * entering a shell at ' ++ callerScope.lexiLoc,
      ' * which is called from ' ++ callerScope.callerLoc )
    console.print(
      ' * key in `quit` or `continue` to leave the shell and continue.' )

    cmdArgs = ( ps1= '' ++prompt++ ' Đ: ', ps2= "Đ| ", inScopeOf=callerScope )
    while true {

      case console.readCommand(*** cmdArgs ) of {
        quit -> { break }
        { continue } -> { break }
        dir -> printDir( callerScope )
        { cmdVal } -> {
          console.print( cmdVal )
          cmdVal = nil # clear it
        }
      }

    } $=> { # catch exceptions

      { { IOError:ioExc } } -> {
        console.fatal <| 'IO error - ' ++ ioExc
        rethrow # escalate it to the program loop of the
        # host interpreter, let it decide what to do.
      }

      { cmdExc } -> {
        console.print( 'Recovered from error', exception=cmdExc )
      }

    }

  }

  {#
   # run a shell within an object's (probably a module) scope, e.g.
  ```edh
  case { import (**_) 'batteries/magic' } of { m } -> shellWith(m)
  ```
   #}
  method shellWith( obj=this ) {

    console.print( ' * entering a shell within ' ++ obj )
    console.print( ' * key in `quit` to leave the shell.' )

    # use scope obj's repr for ps1
    cmdArgs = ( ps1=repr( obj ) ++ ' Đ: ', ps2= "Đ| ", inScopeOf=obj )
    while true {

      case console.readCommand(*** cmdArgs ) of {
        quit -> { break }
        dir -> printDir( scope( ofObj=obj ) )
        { cmdVal } -> {
          console.print( cmdVal )
          cmdVal = nil # clear it
        }
      }

    } $=> { # catch exceptions

      { { IOError:ioExc } } -> {
        console.fatal <| 'IO error - ' ++ ioExc
        rethrow # escalate it to the program loop of the
        # host interpreter, let it decide what to do.
      }

      { cmdExc } -> {
        console.print( 'Recovered from error', exception=cmdExc )
      }

    }

  }

}
